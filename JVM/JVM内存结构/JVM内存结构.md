# 图解JVM内存结构

在java学习过程中，对java基础语法有一定了解，并且可以使用，但对java的底层运行机制还不了解，因此做这个日志，以记录jvm的学习过程
## 一、什么是JVM
### （一）JVM定义

JVM，是java virtual machine的缩写，是一种基于计算机设备的规范
### （二）为什么会出现JVM

不同平台所识别的字节码序列含义不同，例如在Windows平台下的某个指令是0101，但Linux平台下的指令可能是1010，因此不同的平台需要不同的编译器来编译代码，这使得实现相同功能的代码，需要编写多个版本，增加了编码工作量，JVM的出现，只需要编写一淘代码，即可在多个平台运行。
### （三）JVM有什么作用

1、通过JVM，java实现了平台无关性，java语言在不同操作系统中无需重新编译。

2、JVM有自动垃圾回收机制，无需程序员手动进行垃圾回收，极大方便了代码编写，提高程序运行效率。

## 二、JVM如何实现多平台运行
###（一）JVM的内存结构
![JVM内存结构图](/JVM/JVM内存结构/assets/jvm内存结构图.jpg "JVM内存结构图")
###（二）类加载器 Classloader

类加载器，顾名思义，就是将java类的.class文件加载到内存中，简要过程是：将.class文件中的二进制数据读入到内存中，将其放在运行时数据区域的方法区内，然后再堆区域创建一个java.lang.Class对象

类如何进行加载呢？

####1、类加载的生命周期
首先，要知道类加载的过程是什么样的，也就是生命周期是如何的。

简单说，类加载经过以下7个阶段：

加载>>连接（校验、准备、解析）>>初始化>>使用>>卸载

![类加载的生命周期图](/JVM/JVM内存结构/assets/类加载的生命周期.jpg "类加载生命周期图")

#####（1）加载：
加载阶段，虚拟机需要完成以下三件事:

- 通过一个类的全限定名来获取其定义的二进制流;
```
扩展：类的全限定名=包名+类名 如：java.lang.String
```

- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构;

- 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口;

##### （2）链接

- 验证：确保被加载类的正确性

目的是确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
包括：文件格式验证，源数据验证，字节码验证，符号引用验证。

- 准备：为静态变量分配内存，并将其初始化为默认值

这个阶段是正式为类变量分配内存并进行初始化赋值的阶段，这些内存都在方法区中分配，需要注意2点：
```
1、此时内存的分配仅包括静态变量（static），不包过实例变量，实例变量不会再方法区中进行分配，而是在实力运行后堆中进行分配。
2、这里的初始赋值是指数据类型的零值（0，0L，null，false）等
```

- 解析：把类中的符号引用转换为直接引用

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。

##### （3）初始化

初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。

- JVM初始化类的步骤

 1、假如这个类还没有被加载和连接，则程序先加载并连接该类

 2、假如该类的直接父类还没有被初始化，则先初始化其直接父类

 3、假如类中有初始化语句，则系统依次执行这些初始化语句
 
##### （4）使用

类的主动使用包括以下六种：
 
 - 创建类的实例，也就是new的方式
 
 - 访问某个类或接口的静态变量，或者对该静态变量赋值
 
 - 调用类的静态方法
 
 - 反射（如Class.forName(“com.shengsiyuan.Test”)）
 
 - 初始化某个类的子类，则其父类也会被初始化
 
 - Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类
##### （5）卸载
在如下几种情况下，Java虚拟机将结束生命周期

– 执行了System.exit()方法

– 程序正常执行结束

– 程序在执行过程中遇到了异常或错误而异常终止

– 由于操作系统出现错误而导致Java虚拟机进程终止
####2、类的加载器有哪些

（1）Bootstrap Classloader 启动类加载器：负责加载存放在JDK\jre\lib，或被 -Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库

（2）ExtClassLoader 扩展类加载器：加载 JDK\jre\lib\ext目录中，或者由 java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类）

（3）APPClassloader 应用类加载器：加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

（4）自定义类加载器：需要继承ClassLoader，我们只需要重写fineClass方法即可 
<!--todo: 后续需要完善编写自定义类加载的代码-->

#### 3、类的加载机制

了解了上面的几种类加载器，还需要他们是根据什么机制进行加载的。

##### （1）全盘负责
当一个类的加载器负责加载某个class时，该class依赖和引用的其他class也将由该类加载器负责加载，除非显示使用另一个类加载器来加载

##### （2）双亲委派

当一个类加载器收到了类加载请求，它会把这个请求委派给父（parent）类加载器去完成，依次递归，因此所有的加载请求最终都被传送到顶层的启动类加载器中。只有在父类加载器无法加载该类时子类才尝试从自己类的路径中加载该类。（注意：类加载器中的父子关系并不是类继承上的父子关系，而是类加载器实例之间的关系。）
##### （3）缓存机制
加载过的class都会被缓存，除非缓存不存在，才会重新读取类对应的数据，同时转入缓存区。

###（三）运行时数据区域 Runtime Data Area
![JVM内存结构图](/JVM/JVM内存结构/assets/jvm内存结构图.jpg "JVM内存结构图")

从图片可以知道，JVM运行是的数据区，大概分为5个部分

- 堆

而对于Java而言，每个应用都唯一对应一个JVM实例，而每一个JVM实例唯一对应一个堆。堆主要包括关键字 new的对象实例、 this指针，或者数组都放在堆中，并由应用所有的线程共享。堆由JVM的自动内存管理机制所管理，名为垃圾回收—— GC（garbage collection）。

###（四）执行引擎 Execution Engine
###（五）本地接口 Native Interface

## 三、垃圾回收GC

## 四、JVM调优